---
---
Redovisning kmom03
=========================

Jag hade en förhållandevis lång startsträcka med $di och det tog ett bra tag innan jag förstod mig på vad det var som behövdes göras. Jag hade nog fortfarande suttit och klurat på den delen om jag inte fått hjälp med den under torsdagens zoom, stort tack!
När jag väl fick till första injektionen kändes det mycket rimligare och som vanligt uppstod känslan av “det där var ju inte så farligt”. Detta känns som den eviga loopen för programmerare.

Dependency injection handlar om att föra över ansvaret att skapa nödvändiga delar från klienten till en mellanhand, och på så sätt möjliggöra både återanvändning av koden och ändringar i komponenter. Detta gör att applikationen blir mer flexibel och gör den enklare att testa. Service Locator är ett designmönster som har som uppgift att agera mellanhand till klienten för att hämta en eller flera tjänster. Det bidrar också till att kunna hålla klienten enkel och gör så att flera olika klienter kan återanvända Service Locatorn. Det verkar råda delade meningar om Service Locator fortfarande skall användas, där det i psr 11 avråds från. Lazy loading är frekvent återkommande i dagens webb och används ofta för att ladda saker i vald ordning med syftet att förbättra sidan laddningstid. Detta gör att programmeraren kan välja att ladda exempelvis bilder, som ofta tar längre tid, sist i sidans rendering, vilket medför att sidan upplevs betydligt snabbare än om en synkron laddning skett. Ett annat exempel på detta är bilder som ligger under “the fold” på sidan, det vill säga att de inte syns när användaren öppnar sidan utan behöver scrollas ner till för att dyka upp. Att ladda dessa bilder sist gör att sidan kan prioritera det som möter användaren först och ge en bättre användarupplevelse. För att lära mig om dessa begrepp har jag använt mig av wikipedia och följande tre länkar:
[freecodecamp on DI](https://www.freecodecamp.org/news/a-quick-intro-to-dependency-injection-what-it-is-and-when-to-use-it-7578c84fa88f/)  
[stackify on Service Locator](https://stackify.com/service-locator-pattern/)  
[web.dev on Lazy Loading](https://web.dev/lazy-loading/)  

Symfony har en komponent som heter DependencyInjection och som till stora delar liknar den $di som vi använder. Komponenten importeras och används genom notation som är mycket lik vår (och därmed även den i psr11). Laravel använder inte en regelrätt komponent likt Symfony utan har en slags inbyggd constructor-injection. Utöver denna finns även en Method-injection.

Jag gjorde en ny klass för WeatherController, som använder sig av flera modeller, bland annat WeatherMode, som hämtar data från openweathermap och GeoMap som hämtar rätt länk till Openstreetmap med hjälp av koordinaterna. I övrigt har jag hållit min mappstruktur rätt lik den från kmom02 med en mapp för Controllers och en mapp för Modeller och helt enkelt utökat med de nödvändiga controllers och modeller. Koden har blivit lite klumpigare under momentets gång och då det här momentet tog rätt mycket tid av mig har jag vara haft tid att refaktorera en liten del av det. Det finns nog flertalet ställen där jag skulle kunna städa ytterligare, men det får lämnas till nästa moment.   
Jag valde att injicera flera av mina modeller via $di, jag såg ingen anledning till att inte göra det. IpDefault(som hämtar användarens ip), IpTest(som utför ip-testning) och IpGeo fick alla gå via $di. Här behöver jag justera vissa delar då det inte var speciellt smidigt att ha constructor-klasser med parametrar. Detta gjorde att jag ändrade i en del av strukturen för de tre ovan nämnda klasserna. Efter att ha lagt dessa tre i $di gick jag vidare för att jobba med veckans funktionalitet.  
I sista sekund såg jag i chatten ett förtydligande om att man behövde ha med både prognos och historiskt väder, något som inte var helt hundra tydligt. Jag fick därför svänga ihop en snabb-lösning på detta. Jag hade nog gjort det betydligt snyggare om jag förstått att det var detta som det syftades på i början.

När det kommer till externa tjänster trivs jag förhållandevis bra med dem, mycket för att vi sedan tidigare är så pass bekanta med dem i Javascript. Användandet av curl upplevs inte lika smidigt som fetch eller liknande i JS men det fungerade ju bra det med. Mcurl var desto klurigare och det tog mig en bra stund innan förstod vad jag faktiskt höll på med. Jag hade ursprungligen tänkt göra en vädertjänst med prognoser men då de tillhandahöll ett api med onecall för prognoser fick det bli historisk data istället. Ibland tycker jag det är klurigt att navigera i den data man får ut från apierna, men jag har insett att för just detta är firefox utomordentligt då den gör det mycket simplare att förstå vad det är man får returnerat. Openweathermaps dokumentation var en smula svårnavigerad för att förstå vad som gick att använda som gratisanvändare och inte, tålamod har varit nyckeln även under detta moment.

TIL för det här momentet är nog att inte rädas att fråga när man inte förstår, för det kan verkligen ge viktiga insikter som hade varit långt borta annars.
